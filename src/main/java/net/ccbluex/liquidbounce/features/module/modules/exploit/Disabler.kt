/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Category
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.modules.combat.KillAura
import net.ccbluex.liquidbounce.features.module.modules.player.Blink
import net.ccbluex.liquidbounce.features.module.modules.world.scaffolds.Scaffold
import net.ccbluex.liquidbounce.features.module.modules.world.scaffolds.Scaffold2
import net.ccbluex.liquidbounce.script.api.global.Chat
import net.ccbluex.liquidbounce.utils.client.PacketUtils.sendPacket
import net.ccbluex.liquidbounce.utils.client.chat
import net.ccbluex.liquidbounce.utils.client.pos
import net.ccbluex.liquidbounce.utils.extensions.*
import net.ccbluex.liquidbounce.utils.inventory.InventoryUtils
import net.ccbluex.liquidbounce.utils.rotation.RotationUtils
import net.ccbluex.liquidbounce.utils.timing.MSTimer
import net.minecraft.client.gui.inventory.GuiInventory
import net.minecraft.entity.EntityLivingBase
import net.minecraft.init.Items
import net.minecraft.item.ItemStack
import net.minecraft.network.Packet
import net.minecraft.network.play.INetHandlerPlayClient
import net.minecraft.network.play.client.*
import net.minecraft.network.play.client.C03PacketPlayer.*
import net.minecraft.network.play.server.*
import net.minecraft.potion.Potion
import net.minecraft.util.AxisAlignedBB
import net.minecraft.util.BlockPos
import net.minecraft.util.EnumFacing
import net.minecraft.util.Vec3
import java.util.*
import java.util.concurrent.ConcurrentLinkedQueue
import java.util.concurrent.LinkedBlockingQueue
import kotlin.math.sqrt

object Disabler : Module("Disabler", Category.EXPLOIT) {

    private val reduceSpawnLagback by boolean("ReduceSpawnLagback",false)
    private var shouldReduceLagback = false
    private var reducePacketsCount = 0
    private val ignoreLag by boolean("IgnoreLag", false)
    private val ignoreLagDistance by float("IgnoreLag-Distance", 3.0f, 1.0f..10.0f) { ignoreLag }
    val startSprint by boolean("StartSprint", false)
    val noDuplicateSwitch by boolean("NoDuplicateSwitch", true)
    private val grimPlace by boolean("GrimPlace", false)
    val grimExtremePacket by boolean("GrimExtremePacket",false)
    private val matrix by boolean("Matrix", false)
    private val matrixNoCheck by boolean("Matrix-NoModuleCheck", false) { matrix }
    private val matrixNewMoveFix by boolean("Matrix-NewMoveFix", false) { matrix }
    private val matrixOldMoveFix by boolean("Matrix-OldMoveFix", false) { matrix }
    private val matrixMoveOnly by boolean("Matrix-MoveOnly", false) { matrix }
    private val matrixNoMovePacket by boolean("Matrix-NoMovePacket", false) { matrix }
    private val matrixHotbarChange by boolean("Matrix-HotbarChange", false) { matrix }
    private val MatrixDebug by boolean("MatrixDebugger", false) { matrix }
    private var pendingFlagApplyPacket = false
    private var lastMotionX = 0.0
    private var lastMotionY = 0.0
    private var lastMotionZ = 0.0
    private val polar by boolean("Polar",false)
    private val intaveCloudCheck by boolean("IntaveCloudCheck",false)
    val packetQueue = ConcurrentLinkedQueue<C0FPacketConfirmTransaction>()
    private var isProcessing = false
    private val intaveOld by boolean("IntaveOld", false)
    private val intaveReach by boolean("IntaveReach", false) { intaveOld }
    private val intaveReachStrong by boolean("IntaveReachStrong", false) { intaveReach }

    private var intaveMove = false
    private var intaveAttack = false
    private var lastIntaveTarget: EntityLivingBase? = null
    private val vulcanScaffold by boolean("VulcanScaffold", false)
    private val vulcanPacketTick by int("VulcanScaffoldPacketTick", 15, 1..20) { vulcanScaffold }
    private var isCorrected = false
    val verusFly by boolean("VerusFly", false)
    val verusCombat by boolean("VerusCombat", false)
    val onlyCombat by boolean("OnlyCombat", true) { verusCombat }

    private val intaveFly by boolean("intaveFly", false)
    private var shouldDelay = false
    private val packets = LinkedBlockingQueue<Packet<INetHandlerPlayClient>>()

    private val noRotationDisabler by boolean("NoRotationDisabler", false)
    private val modifyMode by choices(
        "Mode",
        arrayOf("ConvertNull", "Spoof", "Zero", "SpoofZero", "Negative", "OffsetYaw", "Invalid"),
        "NoRotationDisabler"
    ) { noRotationDisabler }
    private val offsetAmount by float("OffsetAmount", 6f, -180f..180f) { noRotationDisabler }

    private val basicDisabler by boolean("BasicDisabler", false)
    private val cancelC00 by boolean("CancelC00", true) { basicDisabler }
    private val cancelC0F by boolean("CancelC0F", true) { basicDisabler }
    private val cancelC0A by boolean("CancelC0A", true) { basicDisabler }
    private val cancelC0B by boolean("CancelC0B", true) { basicDisabler }
    private val cancelC07 by boolean("CancelC07", true) { basicDisabler }
    private val cancelC13 by boolean("CancelC13", true) { basicDisabler }
    private val cancelC03 by boolean("CancelC03", true) { basicDisabler }
    private val c03NoMove by boolean("C03-NoMove", true) { basicDisabler }

    private val watchdogMotion by boolean("WatchdogMotion", false)
    private val notWhenStarAvailable by boolean("NotWithStar", true) { watchdogMotion }

    private val watchdogInventory by boolean("WatchdogInventory", false)
    private var c16 = false
    private var c0d = false
    val spigotSpam by boolean("SpigotSpam", false)
    val message by text("Message", "/skill") { spigotSpam }

    private val chatDebug by boolean("ChatDebug", false)

    private var transaction = false
    var isOnCombat = false

    private var flags = 0
    private var execute = false
    private var jump = false

    private val hasStar
        get() = InventoryUtils.findItem(36, 44, Items.nether_star) != null

    private val betaVerus by boolean("VerusBeta", false)
    private val betaVerusSilentFlagApply by boolean("SilentFlagApply", false) { betaVerus }
    private val betaVerusBufferSize by int("BufferSize", 300, 0..1000) { betaVerus }
    private val betaVerusRepeatTimesValue by int("RepeatTimes", 1, 1..5) { betaVerus }
    private val betaVerusRepeatTimesFighting by int("BRepeatTimesFighting", 1, 1..5) { betaVerus }
    private val betaVerusFlagDelay by int("FlagDelay", 40, 35..60) { betaVerus }

    private var betaVerus2Stat = false
    private var betaVerusModified = false
    private val betaVerusPacketBuffer = ArrayDeque<Packet<INetHandlerPlayClient>>()
    private var betaVerusLagTimer = MSTimer()

    private val betaVerusRepeatTimes: Int
        get() = if (isOnCombat) betaVerusRepeatTimesFighting else betaVerusRepeatTimesValue

    private val verusExperimental by boolean("VerusExperimental", false)
    private val verusExpVoidTP by boolean("ExpVoidTP", false) { verusExperimental }
    private val verusExpVoidTPDelay by int("ExpVoidTPDelay", 1000, 0..30000) { verusExpVoidTP }
    private val miniblox by boolean("MinibloxDesync", false)
    private var lastVoidTP = 0L
    private var cancelNext = 0
    private var slotID = -1
    private var aac5014moveAState = 0

    private val polarAirline by boolean("PolarAirline", false)
    private val vulcanMovement1dot8 by boolean("VulcanMovement1.8.x", false)
    private val vulcanAutoClick by boolean("VulcanAutoClick", false)
    private val grizzlyBuffer by boolean("GrizzlyBuffer", false)
    private val grim2343Full by boolean("Grim2343", false)
    private val AAC5014MoveA by boolean("AAC5.0.14-Move-A(Vehicle)", false)
    private val AAC5014MoveA_WithTimer by boolean("AAC5.0.14-Move-A-UseTimer", false) {AAC5014MoveA}
    private val AAC5014MoveA_UseTeleportation by boolean("AAC5.0.14-Move-A-WithTeleport", false) {AAC5014MoveA}
    private val AAC5014MoveA_Speed by float("AAC5.0.14-Move-A-Speed", 0.05F, 0.05F..0.2F) { AAC5014MoveA }
    private val AAC5014MoveB by boolean("AAC5.0.14-Move-B", false)
    private val AAC5014ForceDelay by int("AAC5.0.14-ForceDelay", 7, 1..15) { AAC5014MoveB }
    private val AAC5014Combat by boolean("AAC5.0.14-Combat", false)
    private val viaPlacement by boolean("ViaPlacement", false)

    var startVec = Vec3(0.0, 0.0, 0.0)

    val onBB = handler<BlockBBEvent>{
            event ->
        if(grizzlyBuffer){
            //Simple but works well...
            if(mc.thePlayer.onGround)mc.thePlayer.tryJump()
            event.boundingBox = AxisAlignedBB(-2.0, -1.0, -2.0, 2.0, 1.0, 2.0).offset(event.pos)

        }
    }

    override fun onDisable() {
        super.onDisable()
        if(AAC5014MoveA) {
            if(mc.thePlayer!=null){
                mc.thePlayer.capabilities.flySpeed = 0.05F
                mc.thePlayer.capabilities.isFlying = false
                // 移除不存在的 CustomPathHelper 相关代码
                if(AAC5014MoveA_UseTeleportation){
                    // 简单的传送修复
                    sendPacket(C04PacketPlayerPosition(startVec.xCoord, startVec.yCoord, startVec.zCoord, false))
                    sendPacket(C04PacketPlayerPosition(mc.thePlayer.posX, mc.thePlayer.posY, mc.thePlayer.posZ, false))
                }
            }
            mc.timer.timerSpeed = 1.0F
            Blink.state = false
        }
    }
    
    override fun onEnable() {
        if(mc.thePlayer!=null){
            slotID = mc.thePlayer.inventory.currentItem
            startVec = mc.thePlayer.positionVector
        }
        aac5014moveAState=0
        if(grim2343Full){
            Chat.print("This disabler only work on servers with EssentialsX plugin, and IDK why")
            Chat.print("Toggle on ping spoof, and set ping to any value that higher than 1874(A magical value!)")
            Chat.print("Then spoof ur client to bad-lion, rejoin server with 1.17+ version, and reload disabler, wait for 1 second")
            Chat.print("Then u can do anything u want!")
            if(mc.thePlayer!=null) {
                sendPacket(
                    C0BPacketEntityAction(mc.thePlayer, C0BPacketEntityAction.Action.START_SNEAKING)
                )
                repeat(50) {
                    sendPacket(
                        C0CPacketInput()
                    )
                }
                sendPacket(
                    C0BPacketEntityAction(mc.thePlayer, C0BPacketEntityAction.Action.STOP_SNEAKING)
                )
            }
        }
    }
    
    @Suppress("UNCHECKED_CAST")
    val onPacket = handler<PacketEvent> { event ->
        val player = mc.thePlayer ?: return@handler
        val packet = event.packet
        
        if(noDuplicateSwitch){
            if(packet is C09PacketHeldItemChange){
                if(packet.slotId==slotID){
                    event.cancelEvent()
                }else{
                    slotID=packet.slotId
                }
            }
        }
        
        if(viaPlacement){
            if(packet is C08PacketPlayerBlockPlacement&&packet.placedBlockDirection in 0..5){
                event.cancelEvent()
                sendPacket(
                    C08PacketPlayerBlockPlacement(
                        packet.position,
                        packet.placedBlockDirection,
                        packet.stack,
                        0.5F,
                        0.5F,
                        0.5F
                    )
                )
            }
        }
        
        if(AAC5014Combat){
            if(packet is S12PacketEntityVelocity){
                if(packet.entityID==mc.thePlayer.entityId) {
                    sendPacket(
                        C06PacketPlayerPosLook(
                            player.posX,
                            player.posY + 1E309,
                            player.posZ,
                            player.rotationYaw + 1E-15f,
                            player.rotationPitch - 1E-15f,
                            true
                        )
                    )
                    packet.motionX= 0
                    packet.motionZ= 0
                }
            }
        }
        
        if(grizzlyBuffer&&packet is S08PacketPlayerPosLook){
            Chat.print("[GrizzlyBufferDisabler] Done")
            toggle()
        }
        
        if(vulcanAutoClick){
            if (mc.thePlayer.ticksExisted % 100 == 0 && mc.currentScreen == null
            ) {
                sendPacket(
                    C07PacketPlayerDigging(
                        C07PacketPlayerDigging.Action.START_DESTROY_BLOCK,
                        BlockPos(mc.thePlayer),
                        EnumFacing.UP
                    )
                )
            }
        }
        
        if(vulcanMovement1dot8){
            if(packet is C03PacketPlayer || packet is C0FPacketConfirmTransaction || packet is C00PacketKeepAlive){
                event.cancelEvent()
                Chat.print("§c[Vulcan Movement 1.8.x Disabler] wait for 30 seconds and disable the module, and enjoy flying XD. DO *NOT* QUIT THE GAME during this time.")
            }
        }
        
        if (intaveOld) {
            // 拦截资源包状态数据包
            if (packet is C19PacketResourcePackStatus) {
                event.cancelEvent()
                debugMessage("§cIntaveOld §7cancelled resource pack status")
                return@handler
            }

            // Intave Reach 功能
            if (intaveReach) {
                if (packet is C02PacketUseEntity || packet is C0APacketAnimation) {
                    val target = getIntaveTarget()
                    if (target == null) {
                        event.cancelEvent()
                        debugMessage("§cIntaveReach §7no valid target")
                        return@handler
                    }

                    // 如果距离超过3格且KillAura开启，取消数据包
                    if (player.getDistanceToEntity(target) > 3.0 && KillAura.state) {
                        event.cancelEvent()
                        debugMessage("§cIntaveReach §7cancelled long range attack")
                        return@handler
                    }
                }

                // 位置欺骗攻击 - 发送大量假位置数据包
                if (packet is C03PacketPlayer && intaveMove) {
                    intaveMove = false
                    intaveAttack = true

                    val target = getIntaveTarget() ?: return@handler
                    event.cancelEvent()

                    val rotations = RotationUtils.getRotations(target.posX, target.posY + target.eyeHeight, target.posZ)

                    // 发送大量假位置数据包到目标位置
                    val packetCount = if (intaveReachStrong) 20 else 2
                    repeat(packetCount) {
                        sendPacket(
                            C06PacketPlayerPosLook(
                                target.posX, target.posY, target.posZ,
                                rotations.yaw, rotations.pitch, true
                            )
                        )
                    }

                    // 发送攻击数据包
                    sendPacket(C0APacketAnimation())
                    sendPacket(C02PacketUseEntity(target, C02PacketUseEntity.Action.ATTACK))
                    debugMessage("§cIntaveReach §7sent $packetCount fake position packets")
                }
            }
        }
        
        if (reduceSpawnLagback) {
            if (packet is S08PacketPlayerPosLook && !shouldReduceLagback) {
                val xPosiDiff = packet.x - mc.thePlayer.posX
                val yPosiDiff = packet.y - mc.thePlayer.posY
                val zPosiDiff = packet.z - mc.thePlayer.posZ
                if (xPosiDiff + yPosiDiff + zPosiDiff > 20) {
                    shouldReduceLagback = true
                    reducePacketsCount = 5
                }
            }
            if (shouldReduceLagback && packet is C03PacketPlayer && reducePacketsCount > 0) {
                packet.onGround = true
                if (!packet.rotating) { // fix fly sometimes doesn't land properly since most mc servers all refer to C04, C05, C06 as C03s aka. PacketPlayerInFlying.
                    packet.rotating = true
                    packet.yaw = mc.thePlayer.rotationYaw
                    packet.pitch = mc.thePlayer.rotationPitch
                }
                reducePacketsCount--
            }
        }
        
        // Matrix
        if (matrix) {
            if (matrixNoCheck) {
                if (packet is C03PacketPlayer) {
                    if (matrixNoMovePacket && !packet.isMoving) {
                        event.cancelEvent()
                        if (MatrixDebug) {
                            chat("no move, cancelled")
                        }
                        return@handler
                    }
                    if (matrixOldMoveFix) {
                        // almost completely disable strafe check, nofall
                        packet.onGround = true
                        if (!packet.rotating) { // fix fly sometimes doesn't land properly since most mc servers all refer to C04, C05, C06 as C03s aka. PacketPlayerInFlying.
                            packet.rotating = true
                            packet.yaw = mc.thePlayer.rotationYaw
                            packet.pitch = mc.thePlayer.rotationPitch
                        }
                    }
                    if (matrixNewMoveFix) {
                        if (packet is C06PacketPlayerPosLook && pendingFlagApplyPacket) {
                            pendingFlagApplyPacket = false
                            mc.thePlayer.motionX = lastMotionX
                            mc.thePlayer.motionY = lastMotionY
                            mc.thePlayer.motionZ = lastMotionZ
                        }
                    }
                }
            }
        }
        
        if (grimExtremePacket && mc.thePlayer.ticksExisted > 3) {
            if (packet is C03PacketPlayer) {
                packet.x += 999999
                packet.y += -999999
                packet.z += 999999
            }
        }
        
        // IgnoreLag - 忽略服务器位置同步
        if (ignoreLag && packet is S08PacketPlayerPosLook && mc.thePlayer.ticksExisted > 100) {
            event.cancelEvent()
            val distance = player.getDistance(packet.x, packet.y, packet.z)
            if (distance > ignoreLagDistance) {
                // 距离超过阈值时强制同步位置
                player.setPositionAndRotation(packet.x, packet.y, packet.z, packet.yaw, packet.pitch)
                if (!isCorrected) {
                    debugMessage("§aIgnoreLag §7position corrected (distance: ${"%.2f".format(distance)})")
                    isCorrected = true
                }
            } else {
                // 距离在阈值内时忽略服务器位置修正
                if (isCorrected) {
                    debugMessage("§aIgnoreLag §7status recorded")
                    isCorrected = false
                }
            }
        }
        
        // Basic Disabler
        if (basicDisabler) {
            when (packet) {
                is C00PacketKeepAlive -> if (cancelC00) {
                    event.cancelEvent()
                    debugMessage("Cancelled C00-KeepAlive")
                }

                is C0FPacketConfirmTransaction -> if (cancelC0F) {
                    event.cancelEvent()
                    debugMessage("Cancelled C0F-Transaction")
                }

                is C0APacketAnimation -> if (cancelC0A) {
                    event.cancelEvent()
                    debugMessage("Cancelled C0A-Swing")
                }

                is C0BPacketEntityAction -> if (cancelC0B) {
                    event.cancelEvent()
                    debugMessage("Cancelled C0B-Action")
                }

                is C07PacketPlayerDigging -> if (cancelC07) {
                    event.cancelEvent()
                    debugMessage("Cancelled C07-Digging")
                }

                is C13PacketPlayerAbilities -> if (cancelC13) {
                    event.cancelEvent()
                    debugMessage("Cancelled C13-Abilities")
                }

                is C03PacketPlayer -> if (cancelC03 && !(packet is C04PacketPlayerPosition || packet is C05PacketPlayerLook || packet is C06PacketPlayerPosLook)) {
                    if (c03NoMove && player.isMoving) return@handler
                    event.cancelEvent()
                    debugMessage("Cancelled C03-Flying")
                }
            }
        }

        // NoRotationDisabler
        if (noRotationDisabler && packet is C03PacketPlayer) {
            when (modifyMode) {
                "ConvertNull" -> {
                    if (packet.isMoving) {
                        sendPacket(
                            C04PacketPlayerPosition(
                                packet.x,
                                packet.y,
                                packet.z,
                                packet.onGround
                            )
                        )
                    } else {
                        sendPacket(C03PacketPlayer(packet.onGround))
                    }
                    event.cancelEvent()
                }

                "Spoof" -> {
                    if (packet.getRotating()) {
                        packet.yaw = player.rotationYaw
                        packet.pitch = player.rotationPitch
                    }
                }

                "Zero" -> {
                    if (packet.getRotating()) {
                        packet.yaw = 0.0f
                        packet.pitch = 0.0f
                    }
                }

                "SpoofZero" -> {
                    if (packet.isMoving) {
                        sendPacket(
                            C06PacketPlayerPosLook(
                                packet.x,
                                packet.y,
                                packet.z,
                                0.0f,
                                0.0f,
                                packet.onGround
                            )
                        )
                    } else {
                        sendPacket(
                            C06PacketPlayerPosLook(
                                player.posX,
                                player.posY,
                                player.posZ,
                                0.0f,
                                0.0f,
                                packet.onGround
                            )
                        )
                    }
                    event.cancelEvent()
                }

                "Negative" -> {
                    if (packet.getRotating()) {
                        packet.yaw = -packet.yaw
                        packet.pitch = -packet.pitch
                    }
                }

                "OffsetYaw" -> {
                    if (packet.getRotating()) {
                        packet.yaw += offsetAmount
                    }
                }
            }
        }

        /**
         * Working on Hypixel (Watchdog)
         * Tested on: play.hypixel.net
         * Credit: @localp / Nextgen
         * Original: @billionaire
         */
        if (watchdogMotion) {
            when (packet) {
                is S07PacketRespawn -> {
                    flags = 0
                    execute = false
                    jump = true
                }

                is S08PacketPlayerPosLook -> {
                    if (++flags >= 20) {
                        execute = false
                        flags = 0
                    }
                }
            }
        }

        // Watchdog Inventory
        if (watchdogInventory) {
            if (packet is C16PacketClientStatus) {
                if (c16) {
                    event.cancelEvent()
                }
                c16 = true
            }
            if (packet is C0DPacketCloseWindow) {
                if (c0d) {
                    event.cancelEvent()
                }
                c0d = true
            }
        }

        // Grim Place
        if (grimPlace) {
            if (packet is C08PacketPlayerBlockPlacement && packet.placedBlockDirection in 0..5) {
                event.cancelEvent()
                sendPacket(
                    C08PacketPlayerBlockPlacement(
                        packet.position,
                        6 + packet.placedBlockDirection * 7,
                        packet.stack,
                        packet.placedBlockOffsetX,
                        packet.placedBlockOffsetY,
                        packet.placedBlockOffsetZ
                    )
                )
                debugMessage("§cModified §aPlace §cPacket§7.")
            }
        }

        // IntaveCloudCheck
        if (intaveCloudCheck) {
            if (packet is C0FPacketConfirmTransaction && !isProcessing) {
                event.cancelEvent()
                isProcessing = true
                packetQueue.add(packet)

                if (packetQueue.size >= 50) {
                    sendPacket(packetQueue.poll())
                }
                isProcessing = false
            }
        }

        if (polar) {
            if (packet is S00PacketKeepAlive) {
                event.cancelEvent()
                sendPacket(C00PacketKeepAlive(packet.func_149134_c()))
            }

            if (packet is C00PacketKeepAlive) {
                event.cancelEvent()
            }
        }

        // Intave Fly
        if (intaveFly) {
            if (packet is S08PacketPlayerPosLook) {
                if (player.capabilities.isFlying) {
                    shouldDelay = true
                    debugMessage("§cStarted Canceling IntaveFly")
                }
            }

            if (packet is S32PacketConfirmTransaction && shouldDelay) {
                event.cancelEvent()
                packets.add(packet as Packet<INetHandlerPlayClient>)
            }
        }

        // Verus Combat
        if (verusCombat) {
            if (player.ticksExisted <= 20) {
                isOnCombat = false
                return@handler
            }

            if (onlyCombat && !isOnCombat) {
                return@handler
            }

            /**
             * Works by just simply ignore transaction and not accepting them and send invalid one
             * to bypass Verus cancel transaction "patch" (not sending transaction for too long)
             * This could work on other anti-cheat that don't have a proper transaction handling system
             * But this will mostly be used on Verus, disabled any combat check related to transaction.
             *
             * Credit: @ghost / LB Nextgen
             */
            if (packet is S32PacketConfirmTransaction) {
                event.cancelEvent()
                sendPacket(
                    C0FPacketConfirmTransaction(
                        if (transaction) 1 else -1,
                        if (transaction) -1 else 1,
                        transaction
                    )
                )
                transaction = !transaction
            }

            isOnCombat = false
        }

        if (betaVerus) {
            if (packet is C0FPacketConfirmTransaction) {
                betaVerusPacketBuffer.add(packet as Packet<INetHandlerPlayClient>)
                event.cancelEvent()
                if (betaVerusPacketBuffer.size > betaVerusBufferSize) {
                    if (!betaVerus2Stat) {
                        betaVerus2Stat = true
                        debugMessage("AntiCheat is disabled.")
                    }
                    val packeted = betaVerusPacketBuffer.poll()
                    repeat(betaVerusRepeatTimes) {
                        sendPacket(packeted)
                    }
                }
                debugMessage("Packet C0F IN BufferSize=${betaVerusPacketBuffer.size}")
            } else if (packet is C03PacketPlayer) {
                if (player.ticksExisted % betaVerusFlagDelay == 0 && player.ticksExisted > betaVerusFlagDelay + 1 && !betaVerusModified) {
                    debugMessage("Packet C03 -> BetaVerus Y offset")
                    betaVerusModified = true
                    packet.y -= 11.4514
                    packet.onGround = false
                }
            } else if (packet is S08PacketPlayerPosLook && betaVerusSilentFlagApply) {
                val x = packet.x - player.posX
                val y = packet.y - player.posY
                val z = packet.z - player.posZ
                val diff = sqrt(x * x + y * y + z * z)
                if (diff <= 8) {
                    event.cancelEvent()
                    debugMessage("Silent Flag")
                    sendPacket(
                        C06PacketPlayerPosLook(
                            packet.x,
                            packet.y,
                            packet.z,
                            packet.yaw,
                            packet.pitch,
                            true
                        )
                    )
                }
            }
            if (player.ticksExisted <= 7) {
                betaVerusLagTimer.reset()
                betaVerusPacketBuffer.clear()
            }
        }

        // Verus Experimental
        if (verusExperimental) {
            if (verusExpVoidTP && packet is C03PacketPlayer) {
                if (player.ticksExisted > 20 && player.posY > -64) {
                    if (lastVoidTP + verusExpVoidTPDelay < System.currentTimeMillis()) {
                        lastVoidTP = System.currentTimeMillis()
                        sendPacket(
                            C04PacketPlayerPosition(
                                player.posX,
                                -48.0,
                                player.posZ,
                                true
                            )
                        )
                        sendPacket(
                            C04PacketPlayerPosition(
                                player.posX,
                                player.posY,
                                player.posZ,
                                false
                            )
                        )
                        sendPacket(
                            C04PacketPlayerPosition(
                                player.posX,
                                player.posY,
                                player.posZ,
                                player.onGround
                            )
                        )
                        cancelNext = 2
                        event.cancelEvent()
                        debugMessage("VerusExp VoidTP attempt")
                    }
                }
            } else if (verusExpVoidTP && packet is S08PacketPlayerPosLook && cancelNext > 0) {
                cancelNext--
                event.cancelEvent()
                debugMessage("VerusExp cancelled server position look")
            }
        }
        // fixes movement desyncs, we need to send C0CInput packets with correct inputs.
        if (miniblox && (packet is C04PacketPlayerPosition || packet is C05PacketPlayerLook)) {
            sendPacket(
                C0CPacketInput(
                    player.moveStrafing,
                    player.moveForward,
                    player.isJumping,
                    player.isSneaking
                )
            )
        }
    }

    val onMotion = handler<MotionEvent> { event ->
        val player = mc.thePlayer ?: return@handler

        // it's different from grimVia
        if(polarAirline){
            event.x+=1024F
            event.y+=1024F
            event.z+=1024F
        }

        // make it available
        if (event.eventState == EventState.POST && (!matrixMoveOnly || mc.thePlayer.isMoving)) // check post event
            if (matrix) {
                if (matrixNoCheck) {
                    var changed = false
                    if (matrixHotbarChange) for (i in 0..8) {
                        // find empty inventory slot
                        if (mc.thePlayer.inventory.mainInventory[i] == null && i != mc.thePlayer.inventory.currentItem) {
                            sendPacket(C09PacketHeldItemChange(i))
                            changed = true
                            if (MatrixDebug) {
                                chat("found empty slot $i, switching")
                            }
                            break
                        }
                    }

                    sendPacket(
                        C06PacketPlayerPosLook(
                            mc.thePlayer.posX,
                            mc.thePlayer.posY,
                            mc.thePlayer.posZ,
                            RotationUtils.serverRotation.yaw,
                            RotationUtils.serverRotation.pitch,
                            mc.thePlayer.onGround
                        )
                    )
                    mc.netHandler.addToSendQueue(
                        C08PacketPlayerBlockPlacement(
                            BlockPos(-1, -1, -1),
                            -1,
                            null,
                            0f,
                            0f,
                            0f
                        )
                    )
                    if (MatrixDebug) {
                        chat("sent placement")
                    }

                    if (changed) {
                        sendPacket(C09PacketHeldItemChange(mc.thePlayer.inventory.currentItem))
                        if (MatrixDebug) {
                            chat("switched back")
                        }
                    }
                }
            }
        if (event.eventState != EventState.PRE) return@handler
        if (notWhenStarAvailable && hasStar) return@handler

        if (!watchdogMotion) return@handler

        if (execute && player.airTicks >= 10) {
            if (player.airTicks % 2 == 0) {
                event.x += 0.095
            }
            player.setVelocity(0.0, 0.0, 0.0)
        }

    }

    val onUpdate = handler<UpdateEvent> {
        val player = mc.thePlayer ?: return@handler

        if (AAC5014MoveB){
            if(player.ticksExisted>20&&player.ticksExisted%AAC5014ForceDelay==0&&!mc.isSingleplayer) sendPacket(
                C06PacketPlayerPosLook(player.posX,player.posY + 1E309,player.posZ,player.rotationYaw+1E-15f, player.rotationPitch-1E-15f,false)
            )
        }
        if(AAC5014MoveA){
            if(player.isRiding) aac5014moveAState = 1
            if(!player.isRiding&&aac5014moveAState==1){
                aac5014moveAState++
                Chat.print("Ok, start flying. And disable Disabler after landing")
                // 移除对 Blink 私有字段的访问，直接设置状态
                Blink.state = true
                mc.thePlayer.capabilities.isFlying=true
                mc.thePlayer.capabilities.flySpeed = AAC5014MoveA_Speed
                if(AAC5014MoveA_WithTimer) mc.timer.timerSpeed = 3F
            }
        }
        // watchdogMotion jump
        if (watchdogMotion) {
            if (jump) {
                player.tryJump()
            }
        }
        if (ignoreLag) {
            isCorrected = false
        }
        // Watchdog Inventory
        if (watchdogInventory) {
            c16 = false
            c0d = false
            if (mc.currentScreen is GuiInventory) {
                if (player.ticksExisted % (if (player.isPotionActive(Potion.moveSpeed)) 3 else 4) == 0) {
                    sendPacket(C0DPacketCloseWindow())
                } else if (player.ticksExisted % (if (player.isPotionActive(Potion.moveSpeed)) 3 else 4) == 1) {
                    sendPacket(C16PacketClientStatus(C16PacketClientStatus.EnumState.OPEN_INVENTORY_ACHIEVEMENT))
                }
            }
        }

        // Verus Fly
        if (verusFly) {
            if (!isOnCombat && !player.isDead) {
                val pos = player.position.add(0, if (player.posY > 0) -255 else 255, 0) ?: return@handler
                sendPacket(
                    C08PacketPlayerBlockPlacement(
                        pos,
                        256,
                        ItemStack(Items.water_bucket),
                        0F,
                        0.5F + Math.random().toFloat() * 0.44F,
                        0F
                    )
                )
            } else {
                isOnCombat = false
            }
        }

        // Vulcan Scaffold
        if (vulcanScaffold) {
            if (!(player.isInLiquid || player.isDead || player.isOnLadder)) {
                if (player.isMoving && player.ticksExisted % vulcanPacketTick == 0 && (Scaffold.state || Scaffold2.state) && !mc.thePlayer.isSneaking) {
                    sendPacket(C0BPacketEntityAction(player, C0BPacketEntityAction.Action.START_SNEAKING))
                    sendPacket(C0BPacketEntityAction(player, C0BPacketEntityAction.Action.STOP_SNEAKING))
                }
            }
        }

        if (betaVerus) {
            betaVerusModified = false
            if (betaVerusLagTimer.hasTimePassed(490L)) {
                betaVerusLagTimer.reset()
                if (betaVerusPacketBuffer.isNotEmpty()) {
                    val packet = betaVerusPacketBuffer.poll()
                    repeat(betaVerusRepeatTimes) {
                        sendPacket(packet)
                    }
                    debugMessage("Packet Buffer Dump")
                } else {
                    debugMessage("Empty Packet Buffer")
                }
            }
        }
    }

    val onAttack = handler<AttackEvent> { event ->
        isOnCombat = true
        val player = mc.thePlayer
        if (intaveOld && intaveReach) {
            val target = event.targetEntity as? EntityLivingBase
            if (target != null) {
                lastIntaveTarget = target
                if (player.getDistanceToEntity(target) > 3.0 &&
                    player.onGround &&
                    target.hurtTime <= 1 && KillAura.state
                ) {
                    intaveMove = true
                    debugMessage("§cIntaveReach §7triggered position spoof")
                }
            }
        }
    }

    val onWorld = handler<WorldEvent> {
        isOnCombat = false
        if (betaVerus) {
            betaVerus2Stat = false
            betaVerusPacketBuffer.clear()
            betaVerusLagTimer.reset()
        }
        if (ignoreLag) {
            isCorrected = false
        }
    }

    private fun debugMessage(msg: String) {
        if (chatDebug) {
            chat("§f$msg")
        }
    }

    private fun getIntaveTarget(): EntityLivingBase? {
        return lastIntaveTarget
    }
}