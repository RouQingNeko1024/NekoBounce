/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Category
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.utils.client.PacketUtils.sendPacket
import net.ccbluex.liquidbounce.utils.extensions.isMoving
import net.ccbluex.liquidbounce.utils.timing.TimerHelper
import net.minecraft.network.play.client.*
import net.minecraft.network.play.client.C03PacketPlayer.*

object MatrixDamageGlide : Module("MatrixNoDamageGlide", Category.EXPLOIT) {

    private val glideMode by choices("Mode", arrayOf("Normal", "Ver188MM"), "Normal")

    private var index1 = 0
    private var index2 = 0  // 滑翔阶段标记
    private var index6 = 0  // 计时器恢复标记
    private var index7 = 0  // 剩余刻数

    private val lastVeltimer = TimerHelper()

    val onMotion = handler<MotionEvent> { event ->
        val player = mc.thePlayer ?: return@handler

        // 检查是否在滑翔阶段
        if (index2 == 1) {
            // 1.3秒后自动退出滑翔
            if (lastVeltimer.hasTimeElapsed(1300L, false) && index1 > 4) {
                index2 = 0
            }
            // 锁 Y 运动，实现悬停
            player.motionY = -1.0E-5
        }

        // 滑翔期间锁定视角
        if (index7 > 0) {
            index7--
            // MotionEvent可能不支持直接设置yaw和pitch，跳过这部分
        }

        index1++
    }

    val onPacket = handler<PacketEvent> { event ->
        val player = mc.thePlayer ?: return@handler
        val packet = event.packet

        // Ver188MM模式：直接在PreMotion里发包，不依赖MovePost
        if (glideMode == "Ver188MM" && index2 == 0) {
            if (packet is C03PacketPlayer && packet.isMoving) {
                // 发送两个相反的onGround状态
                sendPacket(C04PacketPlayerPosition(packet.x, packet.y, packet.z, true), true)
                sendPacket(C04PacketPlayerPosition(packet.x, packet.y, packet.z, false), true)

                // 标记进入滑翔状态
                index7 = 3
                index2 = 1
                index6 = 1
                index1 = 0
            }
        }
    }

    val onUpdate = handler<UpdateEvent> {
        val player = mc.thePlayer ?: return@handler

        // 检查是否在滑翔阶段
        if (index2 == 1) {
            // 恢复计时器速度
            if (index6 == 1) {
                index6--
                // 恢复计时器速度到1.0
                mc.timer.timerSpeed = 1.0f
            }
            // 锁定Y轴运动
            player.motionY = -1.0E-5
        }

        // 未开启Ver188MM模式时的触发逻辑
        if (glideMode == "Normal" && index2 == 0) {
            // 三连发：地面 -> 输入 -> 空中
            sendPacket(C04PacketPlayerPosition(player.posX, player.posY, player.posZ, false), true)

            // 发送C0C输入包（模拟玩家输入）
            sendPacket(C0CPacketInput(player.moveStrafing, player.moveForward, player.isJumping, player.isSneaking), true)

            sendPacket(C04PacketPlayerPosition(player.posX, player.posY, player.posZ, true), true)

            // 如果允许降速，则把客户端计时器降到31%
            mc.timer.timerSpeed = 0.31f

            // 标记进入滑翔状态
            index7 = 3   // 剩余刻数
            index2 = 1   // 阶段标记
            index6 = 1   // 计时器恢复标记
            index1 = 0   // 计数器清零
        }

        index1++
    }

    override fun onDisable() {
        // 确保退出时恢复计时器速度
        mc.timer.timerSpeed = 1.0f
        super.onDisable()
    }
}
