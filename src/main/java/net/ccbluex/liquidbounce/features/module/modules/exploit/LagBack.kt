/*
 * LiquidBounce Hacked Client
 * A free open source mixin-based injection hacked client for Minecraft using Minecraft Forge.
 * https://github.com/CCBlueX/LiquidBounce/
 */
package net.ccbluex.liquidbounce.features.module.modules.exploit

import net.ccbluex.liquidbounce.event.*
import net.ccbluex.liquidbounce.features.module.Category
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.utils.client.PacketUtils.sendPacket
import net.ccbluex.liquidbounce.utils.extensions.isMoving
import net.ccbluex.liquidbounce.utils.timing.MSTimer
import net.minecraft.network.Packet
import net.minecraft.network.play.server.S12PacketEntityVelocity
import java.util.*

object LagBack : Module("LagBack", Category.EXPLOIT) {

    private val delay by int("Delay", 3000, 1000..10000) // 击退延迟时间(毫秒)
    private val pauseOnNoMove by boolean("PauseOnNoMove", true)

    private val packetQueue = mutableListOf<PacketData>()
    private val timer = MSTimer()

    override fun onEnable() {
        packetQueue.clear()
        timer.reset()
    }

    override fun onDisable() {
        flushPackets()
    }

    val onPacket = handler<PacketEvent> { event ->
        val player = mc.thePlayer ?: return@handler
        val packet = event.packet

        if (!handleEvents() || player.isDead || event.isCancelled) {
            return@handler
        }

        // 检查是否暂停
        if (pauseOnNoMove && !player.isMoving) {
            flushPackets()
            return@handler
        }

        // 拦截击退包
        if (packet is S12PacketEntityVelocity && packet.entityID == player.entityId) {
            event.cancelEvent()

            // 储存击退包
            packetQueue.add(PacketData(packet, System.currentTimeMillis()))

            // 重置计时器
            timer.reset()
        }
    }

    val onUpdate = handler<UpdateEvent> {
        val player = mc.thePlayer ?: return@handler

        if (!handleEvents() || player.isDead) {
            flushPackets()
            return@handler
        }

        // 检查是否暂停
        if (pauseOnNoMove && !player.isMoving) {
            flushPackets()
            return@handler
        }

        // 检查是否到了发送时间
        if (timer.hasTimePassed(delay.toLong())) {
            flushPackets()
        }
    }

    val onWorld = handler<WorldEvent> { event ->
        // 断开连接时发送所有包
        if (event.worldClient == null) {
            flushPackets()
        }
    }

    private fun flushPackets() {
        if (packetQueue.isEmpty()) return

        // 发送所有储存的包
        synchronized(packetQueue) {
            packetQueue.forEach { data ->
                sendPacket(data.packet, false)
            }
            packetQueue.clear()
        }
    }

    data class PacketData(val packet: Packet<*>, val timestamp: Long)
}
